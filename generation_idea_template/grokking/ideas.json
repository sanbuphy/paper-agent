[
    {
        "Name": "batch_size_grokking",
        "Title": "批量大小Grokking：评估训练批量大小对Grokking现象的影响",
        "Experiment": "修改实验以在训练过程中动态调整批量大小，从小批量开始，逐渐增加。这可能会导致在验证集上更快的泛化。",
        "Interestingness": 6,
        "Feasibility": 4,
        "Novelty": 4,
        "novel": true
    },
    {
        "Name": "learning_rate_grokking",
        "Title": "学习率Grokking：研究自适应学习率调度对Grokking现象的影响",
        "Experiment": "实现各种自适应学习率调度，如循环学习率和学习率热重启。修改'run'函数中的'scheduler'以纳入这些策略。跟踪每种学习率策略在不同数据集上达到99%以上验证准确率所需的批次数。分析这些调度如何影响Grokking的速度和最终的泛化性能。",
        "Interestingness": 8,
        "Feasibility": 6,
        "Novelty": 7,
        "novel": true
    },
    {
        "Name": "noise_impact_grokking",
        "Title": "噪声对Grokking的影响：评估数据噪声在从记忆到泛化转变中的作用",
        "Experiment": "在每个数据集类的'fetch_example'方法中引入高斯噪声。使用一个在实验中变化的参数来控制噪声水平。监测不同噪声水平如何影响达到99%以上验证准确率所需的批次数，并评估最终的泛化性能。分析噪声对不同数学操作数据集的Grokking影响。",
        "Interestingness": 7,
        "Feasibility": 5,
        "Novelty": 8,
        "novel": true
    },
    {
        "Name": "architecture_grokking",
        "Title": "架构对Grokking的影响：分析模型深度和宽度的影响",
        "Experiment": "修改'run'函数中'Transformer'类的初始化，以实验不同层数（例如，2到6）和模型维度（宽度，例如，64到256）。系统地变化这些参数，同时跟踪在不同数据集上达到99%以上验证准确率所需的训练批次数。分析模型深度和宽度如何影响Grokking现象和泛化性能，可能识别出优化Grokking和泛化的架构配置。",
        "Interestingness": 9,
        "Feasibility": 7,
        "Novelty": 8,
        "novel": true
    },
    {
        "Name": "data_augmentation_grokking",
        "Title": "数据增强在Grokking中的应用：探索对泛化的影响",
        "Experiment": "增强每个数据集类的'fetch_train_example'方法，以包括增强策略，例如交换加法和减法的操作数，使用乘法逆元进行除法，以及对置换组进行置换。确保这些变换保持数学操作的完整性。跟踪达到99%以上验证准确率所需的训练批次数，比较有无增强的结果。评估对不同数据集的Grokking和泛化的影响。",
        "Interestingness": 8,
        "Feasibility": 7,
        "Novelty": 8,
        "novel": true
    },
    {
        "Name": "initialization_grokking",
        "Title": "初始化Grokking：探索权重初始化对Grokking现象的影响",
        "Experiment": "修改'Transformer'模型的权重初始化，在Transformer类的'__init__'方法中。实现并测试不同的初始化策略，如Xavier、He和均匀初始化。跟踪每种初始化策略在不同数据集上达到99%以上验证准确率所需的批次数。分析这些初始化如何影响Grokking的速度和最终的泛化性能。",
        "Interestingness": 8,
        "Feasibility": 7,
        "Novelty": 7,
        "novel": true
    },
    {
        "Name": "dropout_grokking",
        "Title": "Dropout Grokking：检查Dropout率对Grokking现象的影响",
        "Experiment": "在Transformer模型的'DecoderBlock'类中集成dropout层，在自注意力和前馈操作后添加dropout层。在'run'函数中实验不同的dropout率（例如，0、0.1、0.3、0.5）。跟踪每种dropout率在不同数据集上达到99%以上验证准确率所需的训练批次数。比较有无dropout的Grokking速度和最终泛化性能。",
        "Interestingness": 8,
        "Feasibility": 7,
        "Novelty": 8,
        "novel": true
    },
    {
        "Name": "optimizer_grokking",
        "Title": "优化器Grokking：研究优化器选择对Grokking现象的影响",
        "Experiment": "修改'run'函数中的'optimizer'初始化，以实验不同的优化算法，如带动量的SGD、RMSprop、Adagrad和Adadelta。跟踪每种优化器在不同数据集上达到99%以上验证准确率所需的训练批次数。比较Grokking速度和最终泛化性能，以确定是否有任何优化器特别增强或阻碍Grokking过程。",
        "Interestingness": 8,
        "Feasibility": 8,
        "Novelty": 7,
        "novel": true
    },
    {
        "Name": "data_sparsity_grokking",
        "Title": "数据稀疏性与Grokking：评估稀疏训练数据对泛化的影响",
        "Experiment": "修改'fetch_train_example'方法，通过随机删除一定比例的训练对来引入稀疏性，同时保持类别平衡。实现从0%到50%的稀疏水平。跟踪在不同稀疏条件下达到99%以上验证准确率所需的训练批次数。分析某些类型的操作或架构是否对数据稀疏性更具鲁棒性，以及这如何影响Grokking速度和泛化性能。",
        "Interestingness": 9,
        "Feasibility": 8,
        "Novelty": 9,
        "novel": true
    },
    {
        "Name": "embedding_init_grokking",
        "Title": "嵌入初始化与Grokking：分析嵌入层初始化对Grokking现象的影响",
        "Experiment": "修改'Transformer'类以允许嵌入层的不同初始化策略。探索均匀、正态和潜在的预训练嵌入。跟踪在不同数据集上达到99%以上验证准确率所需的训练批次数。评估某些初始化方法是否加速Grokking或改善泛化性能，特别关注嵌入层的作用。",
        "Interestingness": 8,
        "Feasibility": 7,
        "Novelty": 8,
        "novel": true
    },
    {
        "Name": "curriculum_grokking",
        "Title": "课程Grokking：渐进学习策略对Grokking现象的影响",
        "Experiment": "通过修改'fetch_train_example'方法实现课程学习策略，最初呈现简单示例（例如，较小数字的操作或较少交换的置换），然后逐渐引入更复杂的示例。引入一个定义进度计划的参数。跟踪在不同数据集上达到99%以上验证准确率所需的训练批次数，并与基线进行比较。分析课程学习如何影响Grokking的速度和最终泛化性能。",
        "Interestingness": 9,
        "Feasibility": 7,
        "Novelty": 9,
        "novel": true
    },
    {
        "Name": "sequence_length_grokking",
        "Title": "序列长度Grokking：研究序列长度对Grokking现象的影响",
        "Experiment": "修改'Transformer'类初始化中的'seq_len'参数，以探索不同的序列长度（例如，3、5、7、9）。跟踪每种序列长度在不同数据集上达到99%以上验证准确率所需的训练批次数。分析序列长度如何影响Grokking现象和泛化性能，可能识别出优化Grokking的序列长度。",
        "Interestingness": 8,
        "Feasibility": 8,
        "Novelty": 8,
        "novel": true
    },
    {
        "Name": "irrelevant_feature_grokking",
        "Title": "无关特征Grokking：研究无关特征对Grokking现象的影响",
        "Experiment": "修改每个数据集类中的'fetch_example'方法，引入额外的输入特征，这些特征不影响输出标签。实现一个参数来控制添加的无关特征数量。跟踪在不同数量的无关特征下达到99%以上验证准确率所需的训练批次数。分析这些特征如何影响Grokking的速度和不同数据集的最终泛化性能。",
        "Interestingness": 9,
        "Feasibility": 8,
        "Novelty": 9,
        "novel": true
    },
    {
        "Name": "regularization_grokking",
        "Title": "正则化Grokking：研究正则化技术对Grokking现象的影响",
        "Experiment": "通过修改'optimizer'和可能的损失函数，将不同的正则化技术（例如，L1、L2、权重衰减）集成到训练过程中。实现并测试每种技术的各种正则化水平。跟踪在不同数据集上达到99%以上验证准确率所需的训练批次数。分析这些技术如何影响Grokking速度和最终泛化性能，识别出特别促进或阻碍Grokking过程的策略。",
        "Interestingness": 9,
        "Feasibility": 8,
        "Novelty": 8,
        "novel": true
    },
    {
        "Name": "encoding_grokking",
        "Title": "编码方案与Grokking：研究输入编码对Grokking现象的影响",
        "Experiment": "修改AbstractDataset类中的'encode'和'decode'方法，以实现不同的编码方案，如独热编码、二进制编码和位置编码。跟踪每种编码方案在不同数据集上达到99%以上验证准确率所需的训练批次数。分析这些编码方案如何影响Grokking现象和泛化性能。",
        "Interestingness": 9,
        "Feasibility": 7,
        "Novelty": 8,
        "novel": true
    },
    {
        "Name": "loss_function_grokking",
        "Title": "损失函数Grokking：探索不同损失函数对Grokking现象的影响",
        "Experiment": "修改'train'和'evaluate'函数，以纳入各种损失函数，如Huber损失、焦点损失和自定义平滑损失函数。跟踪每种损失函数在不同数据集上达到99%以上验证准确率所需的批次数。分析损失函数的选择如何影响Grokking速度和泛化性能，识别出任何增强或阻碍Grokking的损失函数。这将揭示损失景观如何影响学习动态的见解。",
        "Interestingness": 9,
        "Feasibility": 7,
        "Novelty": 9,
        "novel": true
    },
    {
        "Name": "activation_function_grokking",
        "Title": "激活函数Grokking：研究不同激活函数对Grokking现象的影响",
        "Experiment": "修改'DecoderBlock'类，以实验不同的激活函数，如ReLU、Sigmoid、Swish和Mish，替代GELU。跟踪每种激活函数在不同数据集上达到99%以上验证准确率所需的训练批次数。比较这些激活函数如何影响Grokking速度和泛化性能，可能识别出增强Grokking过程的非线性。",
        "Interestingness": 8,
        "Feasibility": 8,
        "Novelty": 8,
        "novel": true
    },
    {
        "Name": "masking_strategy_grokking",
        "Title": "掩码策略Grokking：研究注意力掩码对Grokking现象的影响",
        "Experiment": "修改'DecoderBlock'类，以在自注意力机制中实现不同的掩码策略。实验全掩码（不允许注意力）、部分掩码（随机掩码某些位置）和动态掩码（在训练过程中调整掩码）等策略。跟踪每种掩码策略在不同数据集上达到99%以上验证准确率所需的训练批次数。分析这些策略如何影响Grokking速度和泛化性能，识别出任何促进或阻碍该过程的策略。",
        "Interestingness": 9,
        "Feasibility": 7,
        "Novelty": 9,
        "novel": true
    },
    {
        "Name": "interpretability_grokking",
        "Title": "可解释性与Grokking：揭示Grokking过程中的决策过程",
        "Experiment": "将可解释性方法集成到训练和评估过程中。通过修改'DecoderBlock'类以输出注意力权重，实现Transformer模型的注意力可视化。使用这些可视化跟踪模型的关注点如何在训练过程中从记忆转向泛化。此外，集成特征重要性技术，如SHAP或LIME，以识别在不同训练阶段最具影响力的输入特征。跟踪达到99%验证准确率所需的批次数，并将这些见解与可解释性结果相关联。分析可解释性如何提供对Grokking现象的更深入见解，并可能指导未来的模型改进。",
        "Interestingness": 9,
        "Feasibility": 7,
        "Novelty": 9,
        "novel": true
    },
    {
        "Name": "representation_analysis_grokking",
        "Title": "表示分析在Grokking中的应用：理解从记忆到泛化的内部转变",
        "Experiment": "在Transformer模型中实现钩子，以捕获不同层和训练阶段的激活和嵌入。使用降维技术，如PCA或t-SNE，来可视化这些表示。跟踪随时间变化的变化，以观察表示如何从记忆演变为泛化。比较不同数据集和训练配置下的表示，以识别共同模式和差异。分析这些见解如何与Grokking现象和泛化性能相关联。",
        "Interestingness": 9,
        "Feasibility": 6,
        "Novelty": 9,
        "novel": true
    },
    {
        "Name": "adversarial_grokking",
        "Title": "对抗性Grokking：研究对抗性训练对Grokking现象的影响",
        "Experiment": "通过实现快速梯度符号法（FGSM）在'train'函数中集成对抗性训练，以在训练过程中生成对抗性示例。将这些对抗性示例纳入训练循环。测量在原始和对抗性数据集上达到99%验证准确率所需的训练批次数。比较有无对抗性训练的Grokking速度和泛化性能。分析对抗性鲁棒性是否影响Grokking转变，提供对模型鲁棒性和泛化的见解。",
        "Interestingness": 9,
        "Feasibility": 6,
        "Novelty": 9,
        "novel": true
    }
]